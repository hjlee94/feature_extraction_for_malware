import os
import glob
import sys
import numpy as np
from tqdm import tqdm


class EncodingManager:
    def __init__(self, inputPath, outputPath , encodingList, nameEncoder, sample_ratio = None):
        self.inputPath = inputPath
        self.outputPath = outputPath
        self.encodingList = encodingList
        self.nameEncoder = nameEncoder
        self.sample_ratio = sample_ratio

        self.featureEncoder = dict()
        self.mergeDict = dict()

        self.dir_stack = list()

    def _sampling(self, input_list):
        np.random.seed(10)
        samples = np.random.choice(input_list, size=int(len(input_list) * self.sample_ratio), replace=False)

        return samples

    def _cut(self, input_list):
        np.random.seed(10)
        samples = np.random.choice(input_list, size=int(self.sample_ratio), replace=False)

        return samples

    def _retrieve(self, inputPath):
        print '[INFO] retrieving [%s]'%inputPath
        inputPath = os.path.join(inputPath, '*')
        fileList = glob.glob(inputPath)

        inputList = list()

        for path in fileList:
            if os.path.isdir(path):
                self.dir_stack.append(os.path.basename(path))
                inputList += self._retrieve(path)
                self.dir_stack.pop()
            else:
                inputList.append(path)

        if self.sample_ratio is not None and len(self.dir_stack) == 1:
            samples = inputList

            if self.sample_ratio < 1.0:
                samples = list(self._sampling(inputList))

            elif len(inputList) > self.sample_ratio:
                samples = list(self._cut(inputList))

            print '[INFO] [%s] data sampled %d -> %d' % (self.dir_stack[-1], len(inputList), len(samples))
            inputList = samples

        return inputList

    def loadToDict(self, path):
        dataDict = dict()

        fd = open(path)

        for line in fd:
            line = line.strip()
            line = line.split()

            fileName = line[0]
            featureVector = line[1:]

            featureDict = dict()

            for feature in featureVector:
                feature = feature.split(':')
                dim = str(feature[0])
                val = float(feature[1])

                featureDict[dim] = val

            dataDict[fileName] = featureDict

        fd.close()

        return dataDict

    def encode(self):
        if not os.path.exists(self.inputPath):
            print '[ERROR] input path not exists. [%s]'%self.inputPath
            sys.exit(0)

        if not os.path.isdir(self.inputPath):
            print '[INFO] single mode on'
            self.encode_single()
        else:
            print '[INFO] multi mode on'
            self.encode_multi()

    def encode_dict(self, dataDict, feature_name, start_index):
        index = start_index

        for fileName in dataDict.keys():
            featureDict = dataDict[fileName]
            encodedFeatureDict = dict()

            for dim in featureDict.keys():
                val = featureDict[dim]

                if dim not in self.featureEncoder[feature_name]:
                    self.featureEncoder[feature_name][dim] = index
                    index += 1

                encodedFeatureDict[self.featureEncoder[feature_name][dim]] = val

            dataDict[fileName] = encodedFeatureDict

        return (dataDict, index)

    def encode_single(self):
        dataDict = self.loadToDict(self.inputPath)

        feature_name = os.path.basename(self.inputPath).split('.')[0]
        self.featureEncoder[feature_name] = dict()
        (self.mergeDict,_) = self.encode_dict(dataDict, feature_name, 1)

        self.save()

    def encode_multi(self):
        data_name_set = set()

        print '[INFO] encoding list', self.encodingList

        encodingSet = set([x[0] for x in self.encodingList])
        targetSet = set(filter(lambda x : os.path.isdir(os.path.join(self.inputPath, x)), os.listdir(self.inputPath)))

        if encodingSet != targetSet:
            print '[ERROR] Encoding list does not match with input directories.'
            print '[INFO] EncodingSet : ',encodingSet
            print '[INFO] TargetSet : ',targetSet
            sys.exit(0)

        for (feature_name, _) in self.encodingList:
            data = self._retrieve(os.path.join(self.inputPath, feature_name))
            data_name = map(lambda x: os.path.basename(x).split('.')[0], data)
            data_name = set(data_name)

            data_name_set = data_name_set.union(data_name)

        fd = open(self.outputPath, 'w')
        feature_index = [None for x in range(len(self.encodingList))]

        for data_name in tqdm(data_name_set, unit='B'):
            merged_dict = dict()

            for (idx , (feature_name, start_index)) in enumerate(self.encodingList):
                dataDict = self.loadToDict(os.path.join(self.inputPath,feature_name,data_name) + '.' + feature_name)

                if feature_index[idx] is None:
                    feature_index[idx] = start_index
                    self.featureEncoder[feature_name] = dict()

                (encodedDict, feature_index[idx]) = self.encode_dict(dataDict, feature_name, feature_index[idx])
                merged_dict.update(encodedDict[data_name])

            feature_vector = [self.nameEncoder[data_name]]
            for dim in sorted(merged_dict.keys()):
                val = merged_dict[dim]
                feature_vector.append('%s:%f'%(dim, float(val)))
            fd.write(' '.join(feature_vector) + '\n')

        fd.close()

    def save(self):
        fd = open(self.outputPath, 'w')

        print '[INFO] save merged dictionary ...'
        for fileName in tqdm(self.mergeDict.keys(), unit='B'):
            if fileName not in self.nameEncoder:
                print fileName
                continue

            featureVector = [self.nameEncoder[fileName]]

            for dim in sorted(self.mergeDict[fileName].keys()):
                val = self.mergeDict[fileName][dim]

                featureVector.append("%s:%f"%(dim, float(val)))

            fd.write(' '.join(featureVector)+'\n')

        fd.close()
