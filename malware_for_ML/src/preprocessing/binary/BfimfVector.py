from preprocessing.binary.BinaryUnit import BinaryUnit
from sklearn.feature_extraction.text import TfidfVectorizer
import numpy as np
import math
import os


class BfimfVector(BinaryUnit):
    def __init__(self):
        BinaryUnit.__init__(self, self.__class__.__name__)

        self.WINDOW_SIZE = 1024
        self.STEP_SIZE = 256
        self.BYTE_SIZE = 256

        self.fileName = None
        self.result = None

    def _extractByteSeq(self, inputPath):
        fd = open(inputPath, 'rb')

        byteSequence = map(ord, fd.read())

        return byteSequence

    def _vectorize(self, byteSeq):
        model = TfidfVectorizer()
        byteSeq = map(str, byteSeq)
        byteSequence = [' '.join(byteSeq)]

        res = model.fit_transform(byteSequence)

        return (model.get_feature_names(), res.toarray().flatten())

    def saveResult(self):
        BinaryUnit.saveResult(self) #if result is None, throw Exception
        resultPath = os.path.join(self.resDir,self.fileName)

        fd = open(resultPath+'.'+self.symbol, 'w')
        resContents = [self.fileName]

        for name, value in zip(self.result[0], self.result[1]):
            resContents.append('%s:%f'%(name, value))

        fd.write(' '.join(resContents))
        fd.close()

    def fit_transform(self, inputPath):
        self.fileName = os.path.basename(inputPath).split('.')[0]

        byteSequence = self._extractByteSeq(inputPath)
        tfidf = self._vectorize(byteSequence)

        self.result = tfidf

        return self.result
