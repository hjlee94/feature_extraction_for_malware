from preprocessing.binary.BinaryUnit import BinaryUnit
import numpy as np
import math
import os


class ByteEntropyArr(BinaryUnit):
    def __init__(self):
        BinaryUnit.__init__(self, self.__class__.__name__)

        self.WINDOW_SIZE = 1024
        self.STEP_SIZE = 256
        self.BYTE_SIZE = 256

        self.fileName = None
        self.result = None

    def _getEntropy(self, val):
        try:
            entropyVal = -1 * val * math.log(val, 2)
        except ValueError:
            entropyVal = 0

        return entropyVal

    def _extractByteSeq(self, inputPath):
        fd = open(inputPath, 'rb')

        byteSequence = map(ord, fd.read())

        return byteSequence

    def _convolution(self, byteSeq):
        byteEntropyArr = list()

        for i in range(0, len(byteSeq) - self.WINDOW_SIZE +1, self.STEP_SIZE):
            byteWindow = byteSeq[i:i+self.WINDOW_SIZE]
            byteWindow = np.array(byteWindow)

            byteFreq = np.zeros(self.BYTE_SIZE)

            for byte_value in range(self.BYTE_SIZE):
                cnt = len(np.where(byteWindow==byte_value)[0])
                byteFreq[byte_value] = cnt

            byteFreq = byteFreq / float(np.sum(byteFreq)) # ratio
            byteFreq = map(lambda  x: self._getEntropy(x), byteFreq)
            byteEntropyArr += byteFreq

        #print np.array(byteEntropyArr).shape

        return byteEntropyArr

    def saveResult(self):
        BinaryUnit.saveResult(self) #if result is None, throw Exception
        resultPath = os.path.join(self.resDir,self.fileName)

        fd = open(resultPath+'.'+self.symbol, 'w')
        resContents = [self.fileName]

        for i in range(len(self.result)):
            if self.result[i] <= 0:
                continue

            resContents.append('%d:%f'%(i+1, self.result[i]))

        fd.write(' '.join(resContents))
        fd.close()

    def fit_transform(self, inputPath):
        self.fileName = os.path.basename(inputPath).split('.')[0]

        byteSequence = self._extractByteSeq(inputPath)
        byteEntropyArr = self._convolution(byteSequence)

        self.result = byteEntropyArr

        return self.result
