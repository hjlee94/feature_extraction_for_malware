from preprocessing.binary.BinaryUnit import BinaryUnit
import math
import numpy as np
import os


class ByteEntropyMap(BinaryUnit):
    def __init__(self):
        BinaryUnit.__init__(self, self.__class__.__name__)

        self.BYTE_SIZE = 256
        self.STEP_SIZE = 256
        self.WINDOW_SIZE = 1024
        self.HIST_SIZE = 16

        self.fileName = None
        self.result = None

        self.ROW_CUT = np.round(float(0.5) / self.HIST_SIZE, 4)
        self.COL_CUT = np.ceil(float(self.BYTE_SIZE) / self.HIST_SIZE)

    def _mapRowIndex(self, val):
        rowIdx = int(val / self.ROW_CUT)

        return rowIdx

    def _mapColIndex(self, val):
        colIdx = int(val / self.COL_CUT)

        return colIdx

    def _mapValue(self, entropy_list, histogram_list):
        entropyMatrix = np.zeros((self.HIST_SIZE, self.HIST_SIZE), dtype=int)

        for entropyVal, byteHist in zip(entropy_list, histogram_list):
            for byte_idx in range(self.BYTE_SIZE):
                rowIdx = self._mapRowIndex(entropyVal[byte_idx])
                colIdx = self._mapColIndex(byte_idx)

                entropyMatrix[rowIdx,colIdx] += byteHist[byte_idx]

        return entropyMatrix

    def _getEntropy(self, byteFreq):
        entropyVal = -(np.log(byteFreq) * byteFreq)

        return entropyVal

    def _slide_window(self, byteSeq):
        entropy_list = list()
        histogram_list = list()

        for i in range(0, len(byteSeq) - self.WINDOW_SIZE +1, self.STEP_SIZE):
            byteWindow = byteSeq[i:i+self.WINDOW_SIZE]
            byteWindow = np.array(byteWindow)

            byteHist = np.histogram(byteWindow, bins=256)[0]

            byteFreq = (byteHist / float(np.sum(byteHist))) + 1e-10
            # entropyFreq = map(lambda x:self._getEntropy(x), byteFreq)
            entropyFreq = self._getEntropy(byteFreq)

            histogram_list.append(byteHist)
            entropy_list.append(entropyFreq)

        return (entropy_list, histogram_list)

    def _extractByteSeq(self, inputPath):
        ext = os.path.basename(inputPath).split('.')[-1]

        if ext == 'bytes':
            fd = open(inputPath)

            byteSequence = fd.read().split()

            byteSequence = map(lambda x: int(x, 16), byteSequence)

        else:
            fd = open(inputPath, 'rb')
            byteSequence = map(ord, fd.read())

        return byteSequence

    def saveResult(self):
        BinaryUnit.saveResult(self) #if result is None, throw Exception
        resultPath = os.path.join(self.resDir,self.fileName)

        res = self.result
        res = res.reshape(1,-1).flatten()

        fd = open(resultPath+'.'+self.symbol, 'w')
        resContents = [self.fileName]

        for i in range(len(res)):
            resContents.append('%d:%d'%(i+1, res[i]))

        fd.write(' '.join(resContents))
        fd.close()

    def fit_transform(self, inputPath):
        self.fileName = os.path.basename(inputPath).split('.')[0]

        byteSequence = self._extractByteSeq(inputPath)
        (entropy_list, histogram_list) = self._slide_window(byteSequence)
        # (entropy_list) = self._slide_window(byteSequence)

        self.result = self._mapValue(entropy_list, histogram_list)

        return self.result
