from preprocessing.binary.BinaryUnit import BinaryUnit
import numpy as np
import os


class ByteHistogram(BinaryUnit):
    def __init__(self):
        BinaryUnit.__init__(self, self.__class__.__name__)

        self.WINDOW_SIZE = 1024
        self.STEP_SIZE = 256
        self.BYTE_SIZE = 256

        self.fileName = None
        self.result = None

    def _extractByteSeq(self, inputPath):
        fd = open(inputPath, 'rb')

        byteSequence = map(ord, fd.read())

        return byteSequence

    def _convolution(self, byteSeq):
        byteEntropyArr = list()

        for i in range(0, len(byteSeq) - self.WINDOW_SIZE + 1, self.STEP_SIZE):
            byteWindow = byteSeq[i:i + self.WINDOW_SIZE]
            byteWindow = np.array(byteWindow)

            byteFreq = np.zeros(self.BYTE_SIZE)

            for byte_value in range(self.BYTE_SIZE):
                cnt = len(np.where(byteWindow == byte_value)[0])
                byteFreq[byte_value] = cnt

            byteEntropyArr += byteFreq

        #print np.array(byteEntropyArr).shape

        return byteEntropyArr

    def saveResult(self):
        BinaryUnit.saveResult(self) #if result is None, throw Exception
        resultPath = os.path.join(self.resDir,self.fileName)

        fd = open(resultPath + '.' + self.symbol, 'w')
        resContents = [self.fileName]

        for i in range(len(self.result)):
            resContents.append('%d:%d'%(i+1, self.result[i]))

        fd.write(' '.join(resContents))
        fd.close()

    def fit_transform(self, inputPath):
        self.fileName = os.path.basename(inputPath).split('.')[0]

        byteSequence = self._extractByteSeq(inputPath)
        byteHistogram = self._convolution(byteSequence)

        self.result = byteHistogram

        return self.result
