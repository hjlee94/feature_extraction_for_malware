from preprocessing.binary.BinaryUnit import BinaryUnit
import math
import numpy as np
import os

# Entropy Vis: Malware Image Classification
class EntropyImage(BinaryUnit):
    def __init__(self):
        BinaryUnit.__init__(self, self.__class__.__name__)

        self.DIVIDE_SIZE = 256
        self.BYTE_SIZE = 256

        self.STEP_SIZE = 1
        self.WINDOW_SIZE = 2

        self.fileName = None
        self.result = None

    def _getEntropy(self, byteFreq):
        byteFreq = byteFreq / float(np.sum(byteFreq))

        entropyVal = 0.0

        for idx in range(self.BYTE_SIZE):
            value = byteFreq[idx]
            try:
                entropyVal -= value * math.log(value, 2)
            except:
                pass

        return entropyVal

    def _generateEntImg(self, local_entropy_image):
        entropy_image = np.zeros((256,256))

        pair_dict = dict()

        total_pair = 0
        for idx in range(0, len(local_entropy_image)-self.WINDOW_SIZE-1, self.STEP_SIZE):
            data_pair = local_entropy_image[idx:idx+self.WINDOW_SIZE]

            x = data_pair[0]
            y = data_pair[1]

            key_pair = '%d,%d'%(x,y)

            if key_pair in pair_dict:
                pair_dict[key_pair] = +1
            else:
                pair_dict[key_pair] = 1

            total_pair += 1

        for key_pair in pair_dict.keys():
            pair = key_pair.split(',')
            x = int(pair[0])
            y = int(pair[1])

            freq = pair_dict[key_pair]
            entropy_image[x,y] = int(np.ceil(255 * (freq / float(total_pair))))

        return entropy_image

    def _generateLocalEntImg(self, entropy_list):
        local_entropy_image = np.zeros(len(entropy_list))

        for idx, entropy_val in enumerate(entropy_list):
            value = np.ceil(2 ** entropy_val - 1)
            local_entropy_image[idx] = int(value)

        return local_entropy_image

    def _divide(self, byteSequence):
        entropy_list = list()

        for i in range(0,len(byteSequence),self.DIVIDE_SIZE):
            block_data = byteSequence[i:i+self.DIVIDE_SIZE]
            block_data = np.array(block_data)

            byteFreq = np.zeros(self.BYTE_SIZE)

            for byte_value in range(self.BYTE_SIZE):
                cnt = len(np.where(block_data == byte_value)[0])
                byteFreq[byte_value] = cnt

            entropyVal = self._getEntropy(byteFreq)
            entropy_list.append(entropyVal)

        return entropy_list

    def _extractByteSeq(self, inputPath):
        ext = os.path.basename(inputPath).split('.')[-1]

        if ext == 'bytes':
            fd = open(inputPath)

            byteSequence = fd.read().split()
            byteSequence = map(lambda x : int(x, 16), byteSequence)

        else:
            fd = open(inputPath, 'rb')
            byteSequence = map(ord, fd.read())

        return byteSequence

    def saveResult(self):
        BinaryUnit.saveResult(self) #if result is None, throw Exception
        resultPath = os.path.join(self.resDir,self.fileName)

        res = self.result
        res = res.reshape(1,-1).flatten()

        fd = open(resultPath+'.'+self.symbol, 'w')
        resContents = [self.fileName]

        for i in range(len(res)):
            if res[i] <= 0:
                continue

            resContents.append('%d:%d'%(i+1, res[i]))

        fd.write(' '.join(resContents))
        fd.close()

    def fit_transform(self, inputPath):
        # import cv2
        self.fileName = os.path.basename(inputPath).split('.')[0]

        byteSequence = self._extractByteSeq(inputPath)
        entropy_list = self._divide(byteSequence)
        local_entropy_image = self._generateLocalEntImg(entropy_list)
        # print(local_entropy_image)

        entropy_image = self._generateEntImg(local_entropy_image) * 128
        # print entropy_image

        self.result = entropy_image

        return self.result
