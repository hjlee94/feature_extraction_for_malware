from preprocessing.binary.BinaryUnit import BinaryUnit
from scipy.stats import entropy
import math
import numpy as np
import os

'''
class WindowEntropyMap(BinaryUnit):
    def __init__(self):
        BinaryUnit.__init__(self, self.__class__.__name__)

        self.BYTE_SIZE = 256
        self.STEP_SIZE = 256
        self.WINDOW_SIZE = 1024
        self.HIST_SIZE = 16

        self.byte_range = range(self.BYTE_SIZE)

        self.y_bin_range = np.linspace(0, 8, self.HIST_SIZE)[1:]
        self.x_bin_range = np.linspace(0, 255, self.HIST_SIZE)[1:]

        self.fileName = None
        self.result = None


    def _mapRowIndex(self, val):
        rowIdx = np.digitize(val, self.y_bin_range)
        return int(rowIdx)

    def _mapColIndex(self, val):
        colIdx = np.digitize(val, self.x_bin_range)
        print val, colIdx
        return colIdx

    def _mapValue(self, entropy_list, histogram_list):
        entropyMatrix = np.zeros((self.HIST_SIZE, self.HIST_SIZE), dtype=int)

        for entropyVal, byteFreq in zip(entropy_list, histogram_list):
            rowIdx = self._mapRowIndex(entropyVal)
            
            for byte_idx in range(len(byteFreq)):
                colIdx = self._mapColIndex(byte_idx)
                freq = byteFreq[byte_idx]

                entropyMatrix[rowIdx,colIdx] += freq

        return entropyMatrix

    def _getEntropy(self, byteFreq):
        byteFreq = byteFreq / float(np.sum(byteFreq))

        entropyVal = 0.0

        for idx in range(self.BYTE_SIZE):
            value = byteFreq[idx]
            try:
                entropyVal -= value * math.log(value, 2)
            except:
                pass

        return entropyVal

    def _slide_window(self, byteSeq):
        entropy_list = list()
        histogram_list = list()

        for i in range(0, len(byteSeq) - self.WINDOW_SIZE +1, self.STEP_SIZE):
            byteWindow = byteSeq[i:i+self.WINDOW_SIZE]
            byteWindow = np.array(byteWindow)

            byteFreq = np.zeros(self.BYTE_SIZE)

            for byte_value in range(self.BYTE_SIZE):
                cnt = len(np.where(byteWindow==byte_value)[0])
                byteFreq[byte_value] = cnt

            entropyVal = self._getEntropy(byteFreq)

            histogram_list.append(byteFreq)
            entropy_list.append(entropyVal)

        return (entropy_list, histogram_list)

    def _extractByteSeq(self, inputPath):
        ext = os.path.basename(inputPath).split('.')[-1]

        if ext == 'bytes':
            fd = open(inputPath)

            byteSequence = fd.read().split()
            byteSequence = map(lambda x: int(x, 16), byteSequence)

        else:
            fd = open(inputPath, 'rb')
            byteSequence = map(ord, fd.read())

        return byteSequence

    def saveResult(self):
        BinaryUnit.saveResult(self) #if result is None, throw Exception
        resultPath = os.path.join(self.resDir,self.fileName)

        res = self.result
        res = res.reshape(1,-1).flatten()

        fd = open(resultPath+'.'+self.symbol, 'w')
        resContents = [self.fileName]

        for i in range(len(res)):
            resContents.append('%d:%d'%(i+1, res[i]))

        fd.write(' '.join(resContents))
        fd.close()

    def fit_transform(self, inputPath):
        self.fileName = os.path.basename(inputPath).split('.')[0]

        import time

        s0 = time.time()
        byteSequence = self._extractByteSeq(inputPath)
        e0 = time.time()

        s1 = time.time()
        (entropy_list, histogram_list) = self._slide_window(byteSequence)
        e1 = time.time()

        s2 = time.time()
        self.result = self._mapValue(entropy_list, histogram_list)
        e2 = time.time()

        print (e0 -s0), (e1-s1), (e2-s2)

        import cv2

        mat = np.array(self.result)

        cv2.imwrite('%s.bmp' % self.fileName, mat.reshape(16, 16))
        cv2.waitKey(0)

        return self.result
'''
import time

class WindowEntropyMap(BinaryUnit):
    def __init__(self):
        BinaryUnit.__init__(self, self.__class__.__name__)

        self.BYTE_SIZE = 256
        self.STEP_SIZE = 256
        self.WINDOW_SIZE = 1024
        self.HIST_SIZE = 16
        self.ROW_CUT = np.round(float(8.1) / self.HIST_SIZE, 4)

        self.byte_range = range(self.BYTE_SIZE)

        self.fileName = None
        self.result = None

    def _mapRowIndex(self, val):
        rowIdx = int(val / self.ROW_CUT)

        return rowIdx

    def _mapValue(self, entropy_list, histogram_list):
        entropyMatrix = np.zeros((self.HIST_SIZE, self.HIST_SIZE), dtype=int)

        for entropyVal, byteHist in zip(entropy_list, histogram_list):
            rowIdx = self._mapRowIndex(entropyVal)

            entropyMatrix[rowIdx, :] += byteHist

        return entropyMatrix

    def _getEntropy(self, byteFreq):
        entropyVal = -np.sum(np.log(byteFreq) * byteFreq)

        return entropyVal

    def _slide_window(self, byteSeq):
        entropy_list = list()
        histogram_list = list()

        for i in range(0, len(byteSeq) - self.WINDOW_SIZE + 1, self.STEP_SIZE):
            byteWindow = byteSeq[i:i + self.WINDOW_SIZE]
            byteWindow = np.array(byteWindow)

            byteHist = np.histogram(byteWindow, bins=256)[0]

            byteFreq = (byteHist / float(np.sum(byteHist))) + 1e-10
            entropyVal = self._getEntropy(byteFreq)

            byteHist = np.sum(byteHist.reshape(self.HIST_SIZE,-1), axis=1)

            histogram_list.append(byteHist)
            entropy_list.append(entropyVal)

        return (entropy_list, histogram_list)

    def _extractByteSeq(self, inputPath):
        ext = os.path.basename(inputPath).split('.')[-1]

        if ext == 'bytes':
            fd = open(inputPath)

            byteSequence = fd.read().split()
            byteSequence = map(lambda x: int(x, 16), byteSequence)

        else:
            fd = open(inputPath, 'rb')
            byteSequence = map(ord, fd.read())

        return byteSequence

    def saveResult(self):
        BinaryUnit.saveResult(self)  # if result is None, throw Exception
        resultPath = os.path.join(self.resDir, self.fileName)

        res = self.result
        res = res.reshape(1, -1).flatten()

        fd = open(resultPath + '.' + self.symbol, 'w')
        resContents = [self.fileName]

        for i in range(len(res)):
            resContents.append('%d:%d' % (i + 1, res[i]))

        fd.write(' '.join(resContents))
        fd.close()

    def fit_transform(self, inputPath):
        self.fileName = os.path.basename(inputPath).split('.')[0]

        byteSequence = self._extractByteSeq(inputPath)

        (entropy_list, histogram_list) = self._slide_window(byteSequence)

        self.result = self._mapValue(entropy_list, histogram_list)

        return self.result
